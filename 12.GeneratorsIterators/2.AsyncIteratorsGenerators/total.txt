Обычные итераторы и генераторы прекрасно работают с данными, которые не требуют времени для их создания или получения.

Когда мы ожидаем, что данные будут поступать асинхронно, с задержками, можно использовать их асинхронные аналоги и for await..of вместоfor..of.

Синтаксические различия между асинхронными и обычными итераторами:

Перебираемый объект	Асинхронно перебираемый
Метод для получения итератора	Symbol.iterator	Symbol.asyncIterator
next() возвращает	{value:…, done: true/false}	промис, который завершается с {value:…, done: true/false}
Синтаксические различия между асинхронными и обычными генераторами:

Генераторы	Асинхронные генераторы
Объявление	function*	async function*
generator.next() возвращает	{value:…, done: true/false}	промис, который завершается с {value:…, done: true/false}
В веб-разработке мы часто встречаемся с потоками данных, когда они поступают по частям. Например, загрузка или выгрузка большого файла.

Мы можем использовать асинхронные генераторы для обработки таких данных. Также заметим, что в некоторых окружениях, например, браузерах, есть и другое API, называемое Streams (потоки), который предоставляет специальные интерфейсы для работы с такими потоками данных, их преобразования и передачи из одного потока в другой (например, загрузка из одного источника и сразу отправка в другое место).