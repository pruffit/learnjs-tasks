Мы рассмотрели основной алгоритм Drag’n’Drop.

Ключевые идеи:

Поток событий: ball.mousedown → document.mousemove → ball.mouseup (не забудьте отменить браузерный ondragstart).
В начале перетаскивания: запоминаем начальное смещение указателя относительно элемента: shiftX/shiftY – и сохраняем его при перетаскивании.
Выявляем потенциальные цели переноса под указателем с помощью document.elementFromPoint.
На этой основе можно сделать многое.

На mouseup – по-разному завершать перенос: изменять данные, перемещать элементы.
Можно подсвечивать элементы, пока мышь «пролетает» над ними.
Можно ограничить перетаскивание определённой областью или направлением.
Можно использовать делегирование событий для mousedown/up. Один обработчик событий на большой зоне, который проверяет event.target, может управлять Drag’n’Drop для сотен элементов.
И так далее.
Существуют фреймворки, которые строят архитектуру поверх этого алгоритма, создавая такие классы, как DragZone, Droppable, Draggable. Большинство из них делают вещи, аналогичные описанным выше. Вы можете и сами создать вашу собственную реализацию переноса, как видите, это достаточно просто, возможно, проще, чем адаптация чего-то готового.